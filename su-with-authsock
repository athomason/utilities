#!/usr/bin/perl

# Opens a subshell as another user (a la su(1)), after making the SSH_AUTH_SOCK
# file be usable by the target user.  This allows ssh connections from the
# target user to be made using the parent user's authsock.
#
# Restrictions:
#
# * Target user must be a member of the SSH_AUTH_SOCK owner's default group
# * If using sudo (the default), SSH_AUTH_SOCK must be allowed included in
#   env_keep in sudoers

use strict;
use warnings;

use Getopt::Long;
GetOptions('verbose!' => \(my $verbose));

my @su = qw( /usr/bin/sudo -i -u ); # or 'su'

unless (@ARGV) {
    (my $me = $0) =~ s,.*/,,;
    die "usage: $me <username>\n";
}

my $user = shift;
$verbose && warn "Preparing to switch to user $user\n";

my $auth_sock = $ENV{SSH_AUTH_SOCK};
if ($auth_sock && -w $auth_sock) {
    $verbose && warn "\$SSH_AUTH_SOCK found: $auth_sock\n";

    my @stat = stat $auth_sock;

    # check that target user is in the group of the authsock
    my $gid = $stat[5];
    my @group = getgrgid $gid;
    $verbose && warn "\$SSH_AUTH_SOCK has group $group[0]\n";

    my @members = split / /, $group[3];
    if (grep {$_ eq $user} @members) {
        $verbose && warn "$user is in group $group[0]\n";
        (my $auth_dir = $auth_sock) =~ s,/[^/]+$,,;

        my $perms = $stat[2] | 0770;
        if (chmod $perms, $auth_sock, $auth_dir) {
            $verbose && warn sprintf "Changed permissions on %s and %s to 0%o\n", $auth_sock, $auth_dir, $perms;
        }
        else {
            warn "Failed to change permissions: $!\n";
        }
    }
    else {
        warn "$user is not a member of $group[0]; $auth_sock will not be accessible\n";
    }
}
else {
    warn "No writable \$SSH_AUTH_SOCK in environment\n";
}

exec @su, $user;
